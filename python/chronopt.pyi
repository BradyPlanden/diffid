# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing

ObjectiveInput = numpy.typing.NDArray[numpy.float64]
RealVector = typing.Sequence[builtins.float]
RealMatrix = typing.Sequence[RealVector]
ParameterMapping = typing.Mapping[builtins.str, builtins.float]
ObjectiveOutput = builtins.float | ObjectiveInput | RealVector
ObjectiveCallable = typing.Callable[[ObjectiveInput], ObjectiveOutput]

@typing.final
class Builder:
    """High-level builder for optimisation :class:`Problem` instances."""

    def __new__(cls) -> Builder:
        """Create an empty builder with no objective, parameters, or default optimiser."""
        ...

    def set_optimiser(self, optimiser: chronopt.NelderMead | chronopt.CMAES) -> Builder:
        """Configure the default optimiser used when :meth:`Problem.optimize` omits one."""
        ...

    def add_callable(self, obj: ObjectiveCallable) -> Builder:
        """Attach the objective function callable executed during optimisation."""
        ...

    def add_parameter(self, name: builtins.str) -> Builder:
        """Register a named optimisation variable in the order it appears in vectors."""
        ...

    def build(self) -> Problem:
        """Finalize the builder into an executable :class:`Problem`."""
        ...

@typing.final
class CMAES:
    """Covariance Matrix Adaptation Evolution Strategy optimiser."""

    def __new__(cls) -> CMAES:
        """Create a CMA-ES optimiser with library defaults."""
        ...

    def with_max_iter(self, max_iter: builtins.int) -> CMAES:
        """Limit the number of iterations/generations before termination."""
        ...

    def with_threshold(self, threshold: builtins.float) -> CMAES:
        """Set the stopping threshold on the best objective value."""
        ...

    def with_sigma0(self, sigma0: builtins.float) -> CMAES:
        """Set the initial global step-size (standard deviation)."""
        ...

    def with_patience(self, patience_seconds: builtins.float) -> CMAES:
        """Abort the run if no improvement occurs for the given wall-clock duration."""
        ...

    def with_population_size(self, population_size: builtins.int) -> CMAES:
        """Specify the number of offspring evaluated per generation."""
        ...

    def with_seed(self, seed: builtins.int) -> CMAES:
        """Initialise the internal RNG for reproducible runs."""
        ...

    def run(self, problem: Problem, initial: RealVector) -> OptimisationResults:
        """Optimise ``problem`` starting from the provided mean vector."""
        ...

@typing.final
class DiffsolBuilder:
    """Builder for differential-equation problems described through DiffSL."""

    def __new__(cls) -> DiffsolBuilder:
        """Create an empty differential solver builder."""
        ...

    def add_diffsl(self, dsl: builtins.str) -> DiffsolBuilder:
        """Register the DiffSL program describing the system dynamics."""
        ...

    def add_data(self, data: numpy.typing.NDArray[numpy.float64]) -> DiffsolBuilder:
        """Attach observed data used to fit the differential equation."""
        ...

    def with_t_span(self, t_span: RealVector) -> DiffsolBuilder:
        """Set the time sampling points or integration window."""
        ...

    def with_rtol(self, rtol: builtins.float) -> DiffsolBuilder:
        """Adjust the relative integration tolerance."""
        ...

    def with_atol(self, atol: builtins.float) -> DiffsolBuilder:
        """Adjust the absolute integration tolerance."""
        ...

    def add_params(self, params: ParameterMapping) -> DiffsolBuilder:
        """Provide named parameter defaults for the DiffSL program."""
        ...

    def build(self) -> Problem:
        """Create a :class:`Problem` representing the differential solver model."""
        ...

@typing.final
class NelderMead:
    """Classic simplex-based direct search optimiser."""

    def __new__(cls) -> NelderMead:
        """Create a Nelder-Mead optimiser with default coefficients."""
        ...

    def with_max_iter(self, max_iter: builtins.int) -> NelderMead:
        """Limit the number of simplex iterations."""
        ...

    def with_threshold(self, threshold: builtins.float) -> NelderMead:
        """Set the stopping threshold on simplex size or objective reduction."""
        ...

    def with_position_tolerance(self, tolerance: builtins.float) -> NelderMead:
        """Stop once simplex vertices fall within the supplied positional tolerance."""
        ...

    def with_max_evaluations(self, max_evaluations: builtins.int) -> NelderMead:
        """Abort after evaluating the objective ``max_evaluations`` times."""
        ...

    def with_coefficients(
        self,
        alpha: builtins.float,
        gamma: builtins.float,
        rho: builtins.float,
        sigma: builtins.float,
    ) -> NelderMead:
        """Override the reflection, expansion, contraction, and shrink coefficients."""
        ...

    def with_patience(self, patience_seconds: builtins.float) -> NelderMead:
        """Abort if the objective fails to improve within the allotted time."""
        ...

    def run(self, problem: Problem, initial: RealVector) -> OptimisationResults:
        """Optimise ``problem`` starting from the provided initial simplex centre."""
        ...

@typing.final
class OptimisationResults:
    """Container for optimiser outputs and diagnostic metadata."""

    @property
    def x(self) -> builtins.list[builtins.float]:
        """Decision vector corresponding to the best-found objective value."""
        ...

    @property
    def fun(self) -> builtins.float:
        """Objective value evaluated at :attr:`x`."""
        ...

    @property
    def nit(self) -> builtins.int:
        """Number of iterations performed by the optimiser."""
        ...

    @property
    def nfev(self) -> builtins.int:
        """Total number of objective function evaluations."""
        ...

    @property
    def success(self) -> builtins.bool:
        """Whether the run satisfied its convergence criteria."""
        ...

    @property
    def message(self) -> builtins.str:
        """Human-readable status message summarising the termination state."""
        ...

    @property
    def termination_reason(self) -> builtins.str:
        """Structured termination flag describing why the run ended."""
        ...

    @property
    def final_simplex(self) -> builtins.list[builtins.list[builtins.float]]:
        """Simplex vertices at termination, when provided by the optimiser."""
        ...

    @property
    def final_simplex_values(self) -> builtins.list[builtins.float]:
        """Objective values corresponding to :attr:`final_simplex`."""
        ...

    @property
    def covariance(self) -> typing.Optional[RealMatrix]:
        """Estimated covariance of the search distribution, if available."""
        ...

    def __repr__(self) -> builtins.str:
        """Render a concise summary of the optimisation outcome."""
        ...

@typing.final
class Problem:
    """Executable optimisation problem wrapping the Chronopt core implementation."""

    def evaluate(self, x: RealVector) -> builtins.float:
        """Evaluate the configured objective function at ``x``."""
        ...

    def optimize(
        self,
        initial: typing.Optional[RealVector] = None,
        optimiser: chronopt.NelderMead | chronopt.CMAES | None = None,
    ) -> OptimisationResults:
        """Solve the problem starting from ``initial`` using the supplied optimiser."""
        ...

    def get_config(self, key: builtins.str) -> typing.Optional[builtins.float]:
        """Return the numeric configuration value stored under ``key`` if present."""
        ...

    def dimension(self) -> builtins.int:
        """Return the number of parameters the problem expects."""
        ...

def builder_factory_py() -> Builder:
    """Return a convenience factory for creating :class:`Builder` instances."""
    ...
